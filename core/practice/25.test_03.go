package practice

/*
更多的测试手法

GMP
	16.goroutine_01.go
P & -cpu
	最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数
	而go test命令的-cpu标记正是用于设置这个最大个数的
	在默认情况下，最大 P 数量就等于当前计算机 CPU 核心的实际数量
	它们的存在不同大小关系，如此可以在一定程度上模拟拥有不同的 CPU 核心数的计算机
	使用-cpu标记可以模拟被测程序在计算能力不同计算机中的表现

问题：怎样设置-cpu标记的值，以及它会对测试流程产生什么样的影响？
典型回答
	标记-cpu的值应该是一个正整数的列表，该列表的表现形式为：多个整数字面量，比如1,2,4
	针对于此值中的每一个正整数，go test命令都会先设置最大 P 数量为该数，然后再执行测试函数
	如果测试函数有多个，那么go test命令会依照此方式逐个执行
		以1,2,4为例，go test命令会先以1,2,4为最大 P 数量分别去执行第一个测试函数，之后再用同样的方式执行第二个测试函数，以此类推
问题解析
	实际上，不论我们是否追加了-cpu标记，go test命令执行测试函数时流程都是相同的，只不过具体执行步骤会略有不同
	逻辑 CPU 切片
		go test命令在进行准备工作的时候会读取-cpu标记的值，并把它转换为一个以int为元素类型的切片
		即逻辑 CPU 切片
		默认逻辑 CPU 切片只包含一个元素值，即最大 P 数量的默认值，也就是当前计算机 CPU 核心的实际数量
		在准备执行某个测试函数的时候，无论该函数是功能测试函数，还是性能测试函数，go test命令都会迭代逻辑 CPU 切片
		并且在每次迭代时，先依据当前的元素值设置最大 P 数量，然后再去执行测试函数
	性能测试：探索式执行
		注意，对于性能测试函数来说，这里可能不只执行了一次
		go test命令每一次对性能测试函数的执行，都是一个探索的过程
		它会在测试函数的执行时间上限不变的前提下，尝试找到被测程序的最大执行次数
		在这个过程中，性能测试函数可能会被执行多次
		概括为：对性能测试函数的一次探索式执行，这其中包含了对该函数的若干次执行，当然，肯定也包括了对被测程序更多次的执行
	-count
		-count标记是专门用于重复执行测试函数的。它的值必须大于或等于0，并且默认值为1
		运行go test命令的时候追加了-count 5，那么对于每一个测试函数，命令都会在预设的不同条件下（比如不同的最大 P 数量下）分别重复执行五次
	单个性能测试函数
		性能测试函数的执行次数 = `-cpu`标记的值中正整数的个数 * `-count`标记的值 * 探索式执行中测试函数的实际执行次数
		go test -bench="." -run=^$ golang/core/practice/test -cpu 1,2,4 -count 3
	功能测试函数
		功能测试函数的执行次数 = `-cpu`标记的值中正整数的个数 * `-count`标记的值
	测试日志
		在对 Go 程序执行某种自动化测试的过程中，测试日志会显得特别多，而且好多都是重复的
		需要考虑到导致测试函数多次执行的标记和流程
		我们往往需要检查这些标记的使用是否合理、日志记录是否有必要等，从而对测试日志进行精简
			比如，对于功能测试函数来说，我们通常没有必要重复执行它，即使是在不同的最大 P 数量下也是如此
			重复执行指的是，在被测程序的输入（比如说被测函数的参数值）相同情况下的多次执行
	单元测试的意思就是：对单一的功能模块进行边界清晰的测试，并且不掺杂任何对外部环境的检测
		有些时候，在输入完全相同的情况下，被测程序会因其他外部环境的不同，而表现出不同的行为
			这时我们需要考虑的往往应该是：这个程序在设计上是否合理，而不是通过重复执行测试来检测风险
		还有些时候，我们的程序会无法避免地依赖一些外部环境，比如数据库或者其他服务
			这时，我们依然不应该让测试的反复执行成为检测手段，而应该在测试中通过仿造（mock）外部环境，来规避掉它们的不确定性
	对于性能测试函数来说，我们常常需要反复地执行，并以此试图抹平当时的计算资源调度的细微差别对被测程序性能的影响
		通过-cpu标记，我们还能够模拟被测程序在计算能力不同计算机中的性能表现
			设置的最大 P 数量，最好不要超过当前计算机 CPU 核心的实际数量
			因为一旦超出计算机实际的并行处理能力，Go 程序在性能上就无法再得到显著地提升了
			为了管理过多的 P，Go 语言运行时系统还会耗费额外的计算资源
			但这样模拟出的性能一般都会低于程序在计算环境中的实际性能，可以作为一个参考

知识扩展
问题 1：-parallel标记的作用是什么？
	go test 追加标记-parallel
		作用是：设置同一个被测代码包中的功能测试函数的最大并发执行数
		该标记的默认值是测试运行时的最大 P 数量（这可以通过调用表达式runtime.GOMAXPROCS(0)获得）
	功能测试：默认串行
		对于功能测试，为了加快测试速度，命令通常会并发地测试多个被测代码包
		在默认情况下，对于同一个被测代码包中的多个功能测试函数，命令会串行地执行它们
		除非我们在一些功能测试函数中显式地调用t.Parallel方法
	t.Parallel()
		包含了t.Parallel方法调用的功能测试函数就会被go test命令并发地执行，而并发执行的最大数量正是由-parallel标记值决定的
		不过要注意，同一个功能测试函数的多次执行之间一定是串行的
	-parallel标记对性能测试是无效的
		对于性能测试来说，也是可以并发进行的，不过机制上会有所不同
		涉及了b.RunParallel方法、b.SetParallelism方法和-cpu标记的联合运用
		参考：https://golang.google.cn/pkg/testing/
	联合运用-parallel标记和功能测试函数中的t.Parallel方法
		运行命令 go test -v puzzlers/article21/q2或者go test -count=2 -v puzzlers/article21/q2，查看测试结果

问题 2：性能测试函数中的计时器是做什么用的？
	计时器：性能测试专属
		testing.B类型有这么几个指针方法：StartTimer、StopTimer和ResetTimer
		这些方法都是用于操作当前的性能测试函数专属的计时器的
		所谓的计时器，是一个逻辑上的概念，它其实是testing.B类型中一些字段的统称
		这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数
	go test命令本身就会用到这样的计时器
		当准备执行某个性能测试函数的时候，命令会重置并启动该函数专属的计时器
		一旦这个函数执行完毕，命令又会立即停止这个计时器
		如此一来，命令就能够准确地记录下测试函数执行时间了
		然后，命令就会将这个时间与执行时间上限进行比较，并决定是否在改大b.N的值之后，再次执行测试函数
	这三个方法在开始记录、停止记录或重新记录执行时间的同时，也会对堆内存分配字节数和分配次数的记录起到相同的作用
		通过对b.StartTimer和b.StopTimer方法的联合运用，再去除掉任何一段代码的执行时间
		b.ResetTimer方法的灵活性就要差一些了，它只能用于：去除在调用它之前那些代码的执行时间
		无论在调用它的时候，计时器是不是正在运行，它都可以起作用
	示例：在测试函数中自行操作这个计时器
		func BenchmarkGetPrimes(b *testing.B) {
			b.StopTimer()
			time.Sleep(time.Millisecond * 500) // 模拟某个耗时但与被测程序关系不大的操作
			max := 10000
			b.StartTimer()	// 把这个过程所耗费的时间，从当前测试函数的执行时间中去除掉

			for i := 0; i < b.N; i++ {
				GetPrimes(max)
			}
		}

思考
	1. -benchmem标记和-benchtime标记的作用分别是什么？
	2. 怎样在测试的时候开启测试覆盖度分析？如果开启，会有什么副作用吗？
*/
