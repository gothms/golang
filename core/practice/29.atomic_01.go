package practice

/*
原子操作（上）

需求分析
	为了公平起见，调度器总是会频繁地换上或换下这些 goroutine
	换上的意思是，让一个 goroutine 由非运行状态转为运行状态，并促使其中的代码在某个 CPU 核心上执行
	换下的意思是，使一个 goroutine 中的代码中断执行，并让它由运行状态转为非运行状态
	这个中断的时机有很多，任何两条语句执行的间隙，甚至在某条语句执行的过程中都是可以的。即使这些语句在临界区之内也是如此
	所以，互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）
	在众多的同步工具中，真正能够保证原子性执行的只有原子操作（atomic operation）
	原子操作百科：https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/1880992?fr=aladdin
原子操作简介
	原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效
	即使在拥有多 CPU 核心，或者多 CPU 的计算机系统中，原子操作的保证也是不可撼动的
	这使得原子操作可以完全地消除竞态条件，并能够绝对地保证并发安全性。并且，它的执行速度要比其他的同步工具快得多，通常会高出好几个数量级
缺点
	正是因为原子操作不能被中断，所以它需要足够简单，并且要求快速
	如果原子操作迟迟不能完成，而它又不会被中断，那么将会给计算机执行指令的效率带来多么大的影响
	因此，操作系统层面只对针对二进制位或整数的原子操作提供了支持
Go
	Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数
	这些函数都存在于标准库代码包sync/atomic中

问题：sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？
典型回答
	sync/atomic包中的函数可以做的原子操作有：
		加法（add）
		比较并交换（compare and swap，简称 CAS）
		加载（load）
		存储（store）
		交换（swap）
	这些函数针对的数据类型并不多，对这些类型中的每一个，sync/atomic包都会有一套函数给予支持
		int32、int64、uint32、uint64、uintptr、unsafe.Pointer
		针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数
		此外，sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值
问题解析
	第一个衍生问题：原子操作函数的第一个参数值对应的都应该是那个被操作的值，为什么参数类型是*int32而不是int32
		因为原子操作函数需要的是被操作值的指针，而不是这个值本身
		被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，就已经与函数外的那个值毫无关系了
		unsafe.Pointer类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针
		只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内存地址上的数据
	第二个衍生问题：
		当然是可以的。atomic.AddInt32函数的第二个参数代表差量，它的类型是int32，是有符号的
		如果我们想做原子减法，那么把这个差量设置为负整数就可以了
	示例
		用atomic.AddUint32和atomic.AddUint64函数做原子减法
			num := uint32(18)
			delta := int32(-3)
			atomic.AddUint32(&num, uint32(delta))	// 方式一
			atomic.AddUint32(&num, ^uint32(-(-3)-1))	// 方式二
		方式一
			uint32(int32(-3))：Go 编译器会报错，“常量-3不在uint32类型可表示的范围内”，即表达式的结果值溢出
			而 uint32(delta)，可以绕过编译器的检查并得到正确的结果
		方式二
			^uint32(-N-1))，其中的N代表由负整数表示的差量
			此表达式的结果值的补码，与使用前一种方法得到的值的补码相同，所以这两种方式是等价的
			整数在计算机中是以补码的形式存在的，所以在这里，结果值的补码相同就意味着表达式的等价

参见：17.goroutine_02.go
	示例：GoroutineSync()

补充
	使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个 CPU 核心的情况下
	因此，能用原子操作就不要用锁，不过这很有局限性，毕竟原子只能对一些基本的数据类型提供支持
*/
