package practice

/*
访问网络服务

socket简介
	一种 IPC 方法。IPC 是 Inter-Process Communication 的缩写，可以被翻译为进程间通信
	IPC 这个概念（规范）主要定义的是多个进程之间，相互通信的方法。这些方法主要包括：
	系统信号（signal）、管道（pipe）、套接字 （socket）、文件锁（file lock）、消息队列（message queue）、信号灯（semaphore，或信号量）等
	现存的主流操作系统大都对 IPC 提供了强有力的支持，尤其是 socket
Go 语言对 IPC 也提供了一定的支持
	在os代码包和os/signal代码包中就有针对系统信号的 API
	os.Pipe函数可以创建命名管道，而os/exec代码包则对另一类管道（匿名管道）提供了支持
	对于 socket，Go 语言与之相应的程序实体都在其标准库的net代码包中
应用范围
	在众多的 IPC 方法中，socket 是最为通用和灵活的一种
	与其他的 IPC 方法不同，利用 socket 进行通信的进程，可以不局限在同一台计算机当中
	实际上，通信的双方无论存在于世界上的哪个角落，只要能够通过计算机的网卡端口以及网络进行互联，就可以使用 socket
通信范围
	支持 socket 的操作系统一般都会对外提供一套 API
	跑在它们之上的应用程序，利用这套 API 就可以与互联网上的另一台计算机中的程序、同一台计算机中的其他程序，甚至同一个程序中的其他线程进行通信
	例如，在 Linux 操作系统中，用于创建 socket 实例的 API，就是由一个名为socket的系统调用代表的。这个系统调用是 Linux 内核的一部分
系统调用
	可以理解为特殊的 C 语言函数
	它们是连接应用程序和操作系统内核的桥梁，也是应用程序使用操作系统功能的唯一渠道
Go 的 socket 系统调用
	在 Go 语言标准库的syscall代码包中，有一个与这个socket系统调用相对应的函数
	这两者的函数签名是基本一致的，它们都会接受三个int类型的参数，并会返回一个可以代表文件描述符的结果
	但不同的是，syscall包中的Socket函数本身是平台不相关的
	在其底层，Go 语言为它支持的每个操作系统都做了适配，这才使得这个函数无论在哪个平台上，总是有效的
net.Dial函数
	Go 语言的net代码包中的很多程序实体，都会直接或间接地使用到syscall.Socket函数
	比如，我们在调用net.Dial函数的时候，会为它的两个参数设定值
	其中的第一个参数名为network，它决定着 Go 程序在底层会创建什么样的 socket 实例，并使用什么样的协议与其他程序通信

问题：net.Dial函数的第一个参数network有哪些可选值？
典型回答
	net.Dial函数会接受两个参数，分别名为network和address，都是string类型的
	参数network常用的可选值一共有 9 个
	这些值分别代表了程序底层创建的 socket 实例可使用的不同通信协议
		"tcp"：代表 TCP 协议，其基于的 IP 协议的版本根据参数address的值自适应
		"tcp4"：代表基于 IP 协议第四版的 TCP 协议
		"tcp6"：代表基于 IP 协议第六版的 TCP 协议
		"udp"：代表 UDP 协议，其基于的 IP 协议的版本根据参数address的值自适应
		"udp4"：代表基于 IP 协议第四版的 UDP 协议
		"udp6"：代表基于 IP 协议第六版的 UDP 协议
		"unix"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_STREAM 为 socket 类型
		"unixgram"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_DGRAM 为 socket 类型
		"unixpacket"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_SEQPACKET 为 socket 类型
问题解析
	syscall.Socket函数接受三个参数
	func Socket(domain, typ, proto int) (fd Handle, err error)
		参数分别代表想要创建的 socket 实例通信域、类型以及使用的协议
	Socket 的通信域主要有这样几个可选项：IPv4 域、IPv6 域和 Unix 域
		IPv4 域、IPv6 域分别是基于 IP 协议第四版的网络，和基于 IP 协议第六版的网络
		Unix 域，指的是一种类 Unix 操作系统中特有的通信域
		在装有此类操作系统的同一台计算机中，应用程序可以基于此域建立 socket 连接
		这三种通信域分别可以由syscall代码包中的常量AF_INET、AF_INET6和AF_UNIX表示
	Socket 的类型一共有 4 种，分别是：SOCK_DGRAM、SOCK_STREAM、SOCK_SEQPACKET以及SOCK_RAW
		syscall代码包中也都有同名的常量与之对应。前两者更加常用一些
		SOCK_DGRAM中的“DGRAM”代表的是 datagram，即数据报文
			它是一种有数消息边界但没有逻辑连接的非可靠 socket 类型，我们熟知的基于 UDP 协议的网络通信就属于此类
			有消息边界的意思是，与 socket 相关的操作系统内核中的程序在发送或接收数据的时候是以消息为单位的
				可以把消息理解为带有固定边界的一段数据
				内核程序可以自动地识别和维护这种边界，并在必要的时候，把数据切割成一个一个的消息，或者把多个消息串接成连续的数据
				如此一来，应用程序只需要面向消息进行处理就可以了
			有逻辑连接是指，通信双方在收发数据之前必须先建立网络连接
				待连接建立好之后，双方就可以一对一地进行数据传输了
				显然，基于 UDP 协议的网络通信并不需要这样，它是没有逻辑连接的
			只要应用程序指定好对方的网络地址，内核程序就可以立即把数据报文发送出去。这有优势，也有劣势
				优势是发送速度快，不长期占用网络资源，并且每次发送都可以指定不同的网络地址
				最后一个优势有时候也是劣势，因为这会使数据报文更长一些
				其他的劣势有，无法保证传输的可靠性，不能实现数据的有序性，以及数据只能单向进行传输
		SOCK_STREAM这个 socket 类型，恰恰与SOCK_DGRAM相反
			它没有消息边界，但有逻辑连接，能够保证传输的可靠性和数据的有序性，同时还可以实现数据的双向传输
			众所周知的基于 TCP 协议的网络通信就属于此类
			这样的网络通信传输数据的形式是字节流，而不是数据报文
				字节流是以字节为单位的。内核程序无法感知一段字节流中包含了多少个消息，以及这些消息是否完整，这完全需要应用程序自己去把控
				不过，此类网络通信中的一端，总是会忠实地按照另一端发送数据时的字节排列顺序，接收和缓存它们
				所以，应用程序需要根据双方的约定去数据中查找消息边界，并按照边界切割数据，仅此而已
	syscall.Socket函数的第三个参数用于表示 socket 实例所使用的协议
		通常，只要明确指定了前两个参数的值，我们就无需再去确定第三个参数值了，一般把它置为0就可以了
		这时，内核程序会自行选择最合适的协议
		比如，当前两个参数值分别为syscall.AF_INET和syscall.SOCK_DGRAM的时候，内核程序会选择 UDP 作为协议
		又比如，在前两个参数值分别为syscall.AF_INET6和syscall.SOCK_STREAM时，内核程序可能会选择 TCP 作为协议
	高层次API
		在使用net包中的高层次 API 的时候，我们连那前两个参数值都无需给定
		只需要把前面罗列的9个字符串字面量的其中一个，作为network参数的值就好了

知识扩展
问题 1：调用net.DialTimeout函数时给定的超时时间意味着什么？
	超时时间，代表着函数为网络连接建立完成而等待的最长时间
		这是一个相对的时间。它会由这个函数的参数timeout的值表示
		开始的时间点几乎是我们调用net.DialTimeout函数的那一刻
		在这之后，时间会主要花费在“解析参数network和address的值”，以及“创建 socket 实例并建立网络连接”这两件事情上
		不论执行到哪一步，只要在绝对的超时时间达到的那一刻，网络连接还没有建立完成，该函数就会返回一个代表了 I/O 操作超时的错误值
	细节
		在解析address的值的时候，函数会确定网络服务的 IP 地址、端口号等必要信息，并在需要时访问 DNS 服务
		另外，如果解析出的 IP 地址有多个，那么函数会串行或并发地尝试建立连接。但无论用什么样的方式尝试，函数总会以最先建立成功的那个连接为准
		同时，它还会根据超时前的剩余时间去设定针对每次连接尝试的超时时间，以便让它们都有适当的时间执行
	Dialer结构体
		在net包中还有一个名为Dialer的结构体类型
		该类型有一个名叫Timeout的字段，它与上述的timeout参数的含义是完全一致的
		实际上，net.DialTimeout函数正是利用了这个类型的值才得以实现功能的
		net.Dialer 正是net包中这两个（Dial、DialTimeout）“拨号”函数的底层实现

思考
	在你调用了net.Dial等函数之后，如果成功就会得到一个代表了网络连接的net.Conn接口类型的值
	问题是：怎样在net.Conn类型的值上正确地设定针对读操作和写操作的超时时间？
*/
