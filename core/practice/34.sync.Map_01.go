package practice

/*
并发安全字典sync.Map （上）

简介
	一个并发安全的高级数据结构，Go 语言自带的字典类型map并不是并发安全的
	Go 语言官方在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型sync.Map
sync.Map
	这个字典类型提供了一些常用的键值存取操作方法，并保证了这些操作的并发安全
	同时，它的存、取、删等操作都可以基本保证在常数时间内执行完毕。它们的算法复杂度与map类型一样都是O(1)的
	与单纯使用原生map和互斥锁的方案相比，使用sync.Map可以显著地减少锁的争用
	sync.Map本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁
锁
	使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个 CPU 核心的情况下
	因此，能用原子操作就不要用锁，不过这很有局限性，毕竟原子只能对一些基本的数据类型提供支持
注意
	无论在何种场景下使用sync.Map，与原生map明显不同，它只是 Go 语言标准库中的一员，而不是语言层面的东西
	所以，Go 语言的编译器并不会对它的键和值进行特殊的类型检查
	它所有的方法涉及的键和值的类型都是interface{}，也就是空接口
	所以，我们必须在程序中自行保证它的键类型和值类型的正确性

问题：并发安全字典对键的类型有要求吗？
	有要求。键的实际类型不能是函数类型、字典类型和切片类型
问题解析
	原生字典的键类型不能是函数类型、字典类型和切片类型
		并发安全字典内部使用的存储介质正是原生字典
		它使用的原生字典键类型也是可以包罗万象的interface{}
		所以，绝对不能带着任何实际类型为函数类型、字典类型或切片类型的键值去操作并发安全字典
	panic
		这些键值的实际类型只有在程序运行期间才能够确定
		所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类型肯定会引发 panic
	类型安全
		应该在每次操作并发安全字典的时候，都去显式地检查键值的实际类型。无论是存、取还是删
		更好的做法是，把针对同一个并发安全字典的这几种操作都集中起来，然后统一地编写检查代码
		除此之外，把并发安全字典封装在一个结构体类型中，往往是一个很好的选择
	必须保证键的类型是可比较的（或者说可判等的）
		最后的办法是，可以先通过调用reflect.TypeOf函数得到一个键值对应的反射类型值（即：reflect.Type类型的值）
		然后再调用这个值的Comparable方法，得到确切的判断结果

知识扩展
问题 1：怎样保证并发安全字典中的键和值的类型正确性？（方案一）
	简要概括
		使用类型断言表达式或者反射操作来保证它们的类型正确性
	第一种方案，让并发安全字典只能存储某个特定类型的键
		比如，指定这里的键只能是int类型的，或者只能是字符串，又或是某类结构体
		一旦完全确定了键的类型，你就可以在进行存、取、删操作的时候，使用类型断言表达式去对键的类型做检查了
		如果把并发安全字典封装在一个结构体类型里面，就可以通过参数/返回值类型来约束键值类型，让 Go 语言编译器帮助你做类型检查
	小结
		可以完全确定键和值的具体类型的情况
		可以利用 Go 语言编译器去做类型检查，并用类型断言表达式作为辅助
*/
