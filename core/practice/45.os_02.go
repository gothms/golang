package practice

/*
使用os包中的API （下）

知识扩展
问题 1：可应用于File值的操作模式都有哪些？
	针对File值的操作模式主要有只读模式、只写模式和读写模式
		这些模式分别由常量os.O_RDONLY、os.O_WRONLY和os.O_RDWR代表
	还可以为这里的文件设置额外的操作模式
		os.O_APPEND：当向文件中写入内容时，把新内容追加到现有内容的后边
		os.O_CREATE：当给定路径上的文件不存在时，创建一个新文件
		os.O_EXCL：需要与os.O_CREATE一同使用，表示在给定的路径上不能有已存在的文件
		os.O_SYNC：在打开的文件之上实施同步 I/O。它会保证读写的内容总会与硬盘上的数据保持同步
		os.O_TRUNC：如果文件已存在，并且是常规的文件，那么就先清空其中已经存在的任何内容
	示例：Create
		func Create(name string) (*File, error) {
			return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
		}
		如果参数name代表路径之上的文件不存在，那么就新建一个，否则，先清空现存文件中的全部内容
		并且，它返回的File值的读取方法和写入方法都是可用的
	示例：Open
		func Open(name string) (*File, error) {
			return OpenFile(name, O_RDONLY, 0)
		}
问题 2：怎样设定常规文件的访问权限？
	权限模式
	os.OpenFile函数的第三个参数perm代表的是权限模式，其类型是os.FileMode
	实际上，os.FileMode类型能够代表的，可远不只权限模式，它还可以代表文件模式（即文件种类）
	os.FileMode
		基于uint32类型的再定义类型，所以它的每个值都包含了 32 个比特位
		在这 32 个比特位当中，每个比特位都有其特定的含义
		如果在其最高比特位上的二进制数是1，那么该值表示的文件模式就等同于os.ModeDir，也就是说，相应的文件代表的是一个目录
		如果其中的第 26 个比特位上的是1，那么相应的值表示的文件模式就等同于os.ModeNamedPipe，也就是说，那个文件代表的是一个命名管道
		实际上，在一个os.FileMode类型的值中，只有最低的 9 个比特位才用于表示文件的权限
	Perm()：求FileMode
		returns the Unix permission bits in m (m & ModePerm).
		io -> fs -> fs.go -> Perm()
			func (m FileMode) Perm() FileMode {
				return m & ModePerm
			}
		ModePerm FileMode = 0777	// 最低的 9 个比特位上都是1，而更高的 23 个比特位上都是0
	9个比特位：表示文件权限
		每 3 个比特位为一组，共可分为 3 组
		从高到低，这 3 组分别表示的是文件所有者（创建这个文件的用户）、文件所有者所属的用户组，以及其他用户对该文件的访问权限
		而对于每个组，其中的 3 个比特位从高到低分别表示读权限、写权限和执行权限
		如果在其中的某个比特位上的是1，那么就意味着相应的权限开启，否则，就表示相应的权限关闭
	示例
		八进制整数0777就表示：操作系统中的所有用户都对当前的文件有读、写和执行的权限
		而八进制整数0666则表示：所有用户都对当前文件有读和写的权限，但都没有执行的权限
	os.OpenFile
		在调用os.OpenFile函数的时候，可以根据以上说明设置它的第三个参数
		注意，只有在新建文件的时候，这里的第三个参数值才是有效的
		在其他情况下，即使我们设置了此参数，也不会对目标文件产生任何的影响

总结
	os.File类型
		通过该类型的值，我们不但可以对文件进行各种读取、写入、关闭等操作，还可以设定下一次读取或写入时的起始索引位置
		获得此类型值的函数，包括：os.Create、os.NewFile、os.Open和os.OpenFile
	os.Create
		可以在操作系统中创建一个全新的文件，或者清空一个现存文件中的全部内容并重用它
		可以对该文件进行任何的读写操作
	os.NewFile
		并不是被用来创建新文件的，但是它能够基于一个有效的文件描述符包装出一个可用的File值
	os.Open
		打开一个已经存在的文件。但是，我们只能通过它返回的File值对相应的文件进行读操作
	os.OpenFile
		最为灵活的一个函数，可以设定被打开文件的操作模式和权限模式
		实际上，os.Create函数和os.Open函数都只是对它的简单封装而已
	os包的理解
		需要参看操作系统等方面的文档和教程

思考
	怎样通过os包中的 API 创建和操纵一个系统进程？
*/
