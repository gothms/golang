package practice

/*
使用os包中的API （上）

平台不相关的API
	指这些 API 基于（抽象自）操作系统，为我们使用操作系统的功能提供高层次的支持，但是，它们并不依赖于具体的操作系统
os包
	提供的都是平台不相关的 API
	不论是 Linux、macOS、Windows，还是 FreeBSD、OpenBSD、Plan9，os代码包都可以为之提供统一的使用接口
	这使得我们可以用同样的方式，来操纵不同的操作系统，并得到相似的结果
API
	os包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程以及系统信号
	其中，操纵文件系统的 API 最为丰富
	不但可以利用这些 API 创建和删除文件以及目录，还可以获取到它们的各种信息、修改它们的内容、改变它们的访问权限，等
常用数据类型os.File
	对于类 Unix 的操作系统（包括 Linux、macOS、FreeBSD 等），其中的一切都可以被看做是文件
	从字面上来看，os.File类型代表了操作系统中的文件，但远不止于此
	但除了文本文件、二进制文件、压缩文件、目录这些常见的形式之外
	还有符号链接、各种物理设备（包括内置或外接的面向块或者字符的设备）、命名管道，以及套接字（socket），等

问题：os.File类型都实现了哪些io包中的接口？
典型回答
	os.File类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口
	而它的指针类型则实现了很多io代码包中的接口，*os.File实现了：
	io包
		最核心的 3 个简单接口io.Reader、io.Writer和io.Closer
		另外的 3 个简单接口：io.ReaderAt、io.Seeker和io.WriterAt
		正是因为*os.File类型实现了这些简单接口，所以它也顺便实现了io包的 9 个扩展接口中的 7 个
	由于它并没有实现简单接口io.ByteReader和io.RuneReader
		所以它没有实现分别作为这两者的扩展接口的io.ByteScanner和io.RuneScanner
	功能简介
		os.File类型及其指针类型的值，不但可以通过各种方式读取和写入某个文件中的内容
		还可以寻找并设定下一次读取或写入时的起始索引位置
		另外还可以随时对文件进行关闭
	没有的功能
		不能专门地读取文件中的下一个字节或者下一个 Unicode 字符，也不能进行任何的读回退操作
		不过，单独读取下一个字节或字符的功能也可以通过其他方式来实现
		比如，调用它的Read方法并传入适当的参数值就可以做到这一点
问题解析
	实现了哪些io包中的接口，等同于“os.File类型能够以何种方式操作文件？”
	获得 os.File 的类型指针
		Create、NewFile、Open和OpenFile
	文件描述符
		通常由很小的非负整数代表
		它一般会由 I/O 相关的系统调用返回，并作为某个文件的一个标识存在
		从操作系统的层面看，针对任何文件的 I/O 操作都需要用到这个文件描述符
		Go 语言中的一些数据类型，为我们隐匿掉了这个描述符，如此一来我们就无需时刻关注和辨别它了（如os.File类型）
	Fd 与文件描述符
		在调用os.Create函数、os.Open函数以及os.OpenFile函数时，它们都会执行同一个系统调用
		并且在成功之后得到这样一个文件描述符。这个文件描述符将会被储存在它们返回的File值中
		os.File类型有一个指针方法，名叫Fd
		它在被调用之后将会返回一个uintptr类型的值。这个值就代表了当前的File值所持有的那个文件描述符
		在os包中，除了NewFile函数需要用到它，它也没有什么别的用武之地了
	Create
		os.Create函数用于根据给定的路径创建一个新的文件。它会返回一个File值和一个错误值
			我们可以在该函数返回的File值之上，对相应的文件进行读操作和写操作
		创建的文件的读写权限
			使用这个函数创建的文件，对于操作系统中的所有用户来说，都是可以读和写的
			一旦这样的文件被创建出来，任何能够登录其所属的操作系统的用户，都可以在任意时刻读取该文件中的内容，或者向该文件写入内容
		创建的文件已存在
			如果在我们给予os.Create函数的路径之上已经存在了一个文件，那么该函数会先清空现有文件中的全部内容
			然后再把它作为第一个结果值返回
		os.Create函数有可能返回非nil的错误值
			比如，如果我们给定的路径上的某一级父目录并不存在，那么该函数就会返回一个*os.PathError类型的错误值，以表示“不存在的文件或目录”
	NewFile
		该函数在被调用的时候需要接受一个代表文件描述符的、uintptr类型的值，以及一个用于表示文件名的字符串值
			如果我们给定的文件描述符并不是有效的，那么这个函数将会返回nil，否则，它将会返回一个代表了相应文件的File值
		它的功能并不是创建一个新的文件，而是依据一个已经存在的文件的描述符，来新建一个包装了该文件的File值
			示例：拿到一个包装了标准错误输出的File值
			file3 := os.NewFile(uintptr(syscall.Stderr), "/dev/stderr")
	Open
		os.Open函数会打开一个文件并返回包装了该文件的File值
		只读
			该函数只能以只读模式打开文件，不能向它写入任何内容
			调用了这个File值的任何一个写入方法，那么都将会得到一个表示了“坏的文件描述符”的错误值
			只读模式，正是应用在File值所持有的文件描述符之上的
	OpenFile
		这个函数其实是os.Create函数和os.Open函数的底层支持，它最为灵活
		3 个参数，分别名为name、flag和perm
			name：文件的路径
			flag：需要施加在文件描述符之上的模式，只读模式就是这里的一个可选项
				在 Go 语言中，这个只读模式由常量os.O_RDONLY代表，它是int类型的
				除了只读模式之外，还有几个别的模式可选
			perm：也是模式，它的类型是os.FileMode，此类型是一个基于uint32类型的再定义类型
				把参数flag指代的模式叫操作模式，而把参数perm指代的模式叫权限模式
				操作模式限定了操作文件的方式，而权限模式则可以控制文件的访问权限

总结
	os包存在的意义和它的主要用途
		它所包含的 API，都是对操作系统的某方面功能的高层次抽象
		这使得我们可以通过它以统一的方式，操纵不同的操作系统，并得到相似的结果
	os.File
		os.File类型不但可以代表操作系统中的文件，还可以代表很多其他的东西
		尤其是在类 Unix 的操作系统中，它几乎可以代表一切可以操纵的软件和硬件
*/
