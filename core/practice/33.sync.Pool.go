package practice

/*
临时对象池sync.Pool

sync.Pool类型
	临时对象池，它的值可以被用来存储临时的对象
	与 Go 语言的很多同步工具一样，sync.Pool类型也属于结构体类型，它的值在被真正使用之后，就不应该再被复制了
“临时对象”
	不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好
	它们的创建和销毁可以在任何时候发生，并且完全不会影响到程序的功能
	同时，它们也应该是无需被区分的，其中的任何一个值都可以代替另一个
	某类值完全满足上述条件，那么你就可以把它们存储到临时对象池中
主要用途
	把临时对象池当作针对某种数据的缓存来用
API
	sync.Pool类型只有两个方法——Put和Get
	Put
		在当前的池中存放临时对象，它接受一个interface{}类型的参数
	Get
		被用于从当前的池中获取临时对象，它会返回一个interface{}类型的值
		Get方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回
		如果此时当前的池中没有任何值，那么这个方法就会使用当前池的New字段创建一个新值，并直接将其返回
	New 字段
		代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：func() any
		Get
			是Get方法最后的临时对象获取手段
			该函数的结果值并不会被存入当前的临时对象池中，而是直接返回给Get方法的调用方
		初始化
			New字段的实际值需要我们在初始化临时对象池的时候就给定
			否则，在我们调用它的Get方法的时候就有可能会得到nil
			所以，sync.Pool类型并不是开箱即用的
示例：复用 & 清理
	标准库代码包fmt就使用到了sync.Pool类型
		var ppFree = sync.Pool{
			New: func() any { return new(pp) },
		}
	这个包创建一个用于缓存某类临时对象的sync.Pool类型值，并将这个值赋给一个名为ppFree的变量
		这类临时对象可以识别、格式化和暂存需要打印的内容
		临时对象池ppFree的New字段在被调用的时候，总是会返回一个全新的pp类型值的指针（即临时对象）
		保证了ppFree的Get方法总能返回一个可以包含需要打印内容的值
	pp类型
		pp类型是fmt包中的私有类型，它有很多实现了不同功能的方法
		重点是，它的每一个值都是独立的、平等的和可重用的
		这些对象既互不干扰，又不会受到外部状态的影响。它们几乎只针对某个需要打印内容的缓冲区而已
		由于fmt包中的代码在真正使用这些临时对象之前，总是会先对其进行重置，所以它们并不在意取到的是哪一个临时对象
		这就是临时对象的平等性的具体体现
	复用
		这些代码在使用完临时对象之后，都会先抹掉其中已缓冲的内容，然后再把它存放到ppFree中
		这样就为重用这类临时对象做好了准备
		fmt.Println、fmt.Printf等打印函数都是如此使用ppFree，以及其中的临时对象的
		因此，在程序同时执行很多的打印函数调用的时候，ppFree可以及时地把它缓存的临时对象提供给它们，以加快执行的速度
	清理
		而当程序在一段时间内不再执行打印函数调用时，ppFree中的临时对象又能够被及时地清理掉，以节省内存空间
		显然，在这个维度上，临时对象池可以帮助程序实现可伸缩性。这就是它的最大价值
小结
	以上就是临时对象池的基本功能、使用方式、适用场景和存在意义
参见
	02.concurrent -> sync_pool_test.go

问题：为什么说临时对象池中的值会被及时地清理掉？
	因为，Go 语言运行时系统中的垃圾回收器，所以在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除
问题解析
	sync.Pool 初始化时，向 Go 语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值
		func init() {
			runtime_registerPoolCleanup(poolCleanup)
		}
	oldPools []*Pool
	allPools []*Pool
		sync包的包级私有的全局变量
		代表了当前的程序中使用的所有临时对象池的汇总，它是元素类型为*sync.Pool的切片。我们可以称之为池汇总列表
		在一个临时对象池的Put方法或Get方法第一次被调用的时候，这个池就会被添加到池汇总列表中
		正因为如此，池清理函数总是能访问到所有正在被真正使用的临时对象池
	“池清理函数”：一旦池清理函数被注册到了 Go 语言运行时系统，系统在每次即将执行垃圾回收时就都会执行这个函数
		池清理函数会遍历池汇总列表
		对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为nil，然后再把这个池中的所有本地池列表都销毁掉
		最后，池清理函数会把池汇总列表重置为空的切片
		这些池中存储的临时对象就全部被清除干净了
	GC
		如果临时对象池以外的代码再无对它们的引用，那么在稍后的垃圾回收过程中，这些临时对象就会被当作垃圾销毁掉
		它们占用的内存空间也会被回收以备他用

知识扩展
问题 1：临时对象池存储值所用的数据结构是怎样的？
	P
		指的是一种可以承载若干个 G、且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介
		正因为有了 P 的存在，G 和 M 才能够进行灵活、高效的配对，从而实现强大的并发编程模型
		P 存在的一个很重要的原因是为了分散并发程序的执行压力
			而让临时对象池中的本地池列表的长度与 P 的数量相同的主要原因也是分散压力
			压力包括了存储和性能两个方面
	每个本地池都对应着一个 P
		一个 goroutine 要想真正运行就必须先与某个 P 产生关联
		也就是说，一个正在运行的 goroutine 必然会关联着某个 P
		一个临时对象池的Put方法或Get方法会获取到哪一个本地池，完全取决于调用它的代码所在的 goroutine 关联的那个 P
	获取对象
		在程序调用临时对象池的Put方法或Get方法的时候，总会先试图从该临时对象池的本地池列表中，获取与之对应的本地池
		依据的就是与当前的 goroutine 关联的那个 P 的 ID
	sync.Pool 数据结构
		在临时对象池中，有一个多层的数据结构。正因为有了它的存在，临时对象池才能够非常高效地存储大量的值
		这个数据结构的顶层，我们可以称之为本地池列表，它是一个数组
			这个列表的长度，总是与 Go 语言调度器中的 P 的数量相同
		在本地池列表中的每个本地池都包含了三个字段（或者说组件）
		private：存储私有临时对象的字段
		shared：代表了共享临时对象列表的字段
		noCopy：一个sync.Mutex类型的嵌入字段（sync.Locker 接口类型？）
问题 2：临时对象池是怎样利用内部数据结构来存取值的？
	Put
		临时对象池的Put方法总会先试图把新的临时对象，存储到对应的本地池的private字段中，以便在后面获取临时对象时，快速地拿到一个可用的值
		只有当这个private字段已经存有某个值时，该方法才会去访问本地池的shared字段
	Get
		总会先试图从对应的本地池的private字段处获取一个临时对象
		只有当这个private字段的值为nil时，它才会去访问本地池的shared字段
		一个本地池的shared字段原则上可以被任何 goroutine 中的代码访问到，不论这个 goroutine 关联的是哪一个 P
		一个本地池的private字段，只可能被与之对应的那个 P 所关联的 goroutine 中的代码访问到
	Get 共享池
		在互斥锁的保护下，试图把该共享临时对象列表中的最后一个元素值取出并作为结果
		本地共享池为空，Get方法会去访问当前的临时对象池中的所有本地池，它会去逐个搜索它们的共享临时对象列表
			会把某个共享临时对象列表的最后一个元素值取出并作为结果返回
		如果从所有共享池中都没拿到一个可用的临时对象，就调用可创建临时对象的那个 New 字段的函数

总结
	阅读参考 fmt 包对临时对象池的用法
	在临时对象池的内部，有一个多层的数据结构支撑着对临时对象的存储
		它的顶层是本地池列表，其中包含了与某个 P 对应的那些本地池，并且其长度与 P 的数量总是相同的
		在每个本地池中，都包含一个私有的临时对象和一个共享的临时对象列表
		私有对象只能被其对应的 P 所关联的那个 goroutine 中的代码访问到，而共享的临时对象列表却没有这个约束
		前者用于临时对象的快速存取，而后者则用于临时对象的池内共享
	阅读 sync.Pool 源码，掌握其内部结构和存取方式
		这样的内部结构和存取方式，让临时对象池成为了一个特点鲜明的同步工具
		它存储的临时对象都应该是拥有较长生命周期的值，并且，这些值不应该被某个 goroutine 中的代码长期的持有和使用
		因此，临时对象池非常适合用作针对某种数据的缓存
		从某种角度讲，临时对象池可以帮助程序实现可伸缩性，这也正是它的最大价值

思考
	怎样保证一个临时对象池中总有比较充足的临时对象？请从临时对象池的初始化和方法调用两个方面作答
	参考fmt包以及 demo70.go 文件中使用临时对象池的方式
*/
