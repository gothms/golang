package advance

/*
go语句及其执行规则（上）

Don’t communicate by sharing memory; share memory by communicating.
	不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据
	通道（channel）类型的值可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的 goroutine 之间传递数据
进程
	操作系统本身提供了进程和线程这两种并发执行程序的工具
	进程，描述的就是程序的执行过程，是运行着的程序的代表
	换句话说，一个进程其实就是某个程序运行时的一个产物
	如果说静静地躺在那里的代码就是程序的话，那么奔跑着的、正在发挥着既有功能的代码就可以被称为进程
	举例
		我们的电脑为什么可以同时运行那么多应用程序？我们的手机为什么可以有那么多 App 同时在后台刷新？
		这都是因为在它们的操作系统之上有多个代表着不同应用程序或 App 的进程在同时运行
线程
	线程总是在进程之内的，它可以被视为进程中运行着的控制流（或者说代码执行的流程）
	单线程 / 主线程
		一个进程至少会包含一个线程。如果一个进程只包含了一个线程，那么它里面的所有代码都只会被串行地执行
		每个进程的第一个线程都会随着该进程的启动而被创建，它们可以被称为其所属进程的主线程
	多线程
		如果一个进程中包含了多个线程，那么其中的代码就可以被并发地执行
		除了进程的第一个线程之外，其他的线程都是由进程中已存在的线程创建出来的
	线程销毁（系统级线程）
		主线程之外的其他线程都只能由代码显式地创建和销毁
		这需要我们在编写程序的时候进行手动控制，操作系统以及进程本身并不会帮我们下达这样的指令，它们只会忠实地执行我们的指令
		在 Go 程序当中，Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程
		这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程
	用户级线程
		而对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程
		用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理
		优势
			比如，因为它们的创建和销毁并不用通过操作系统去做，所以速度会很快
			又比如，由于不用等着操作系统去调度它们的运行，所以往往会很容易控制并且可以很灵活
		劣势
			最明显也最重要的一个劣势就是复杂
			如果我们只使用了系统级线程，那么我们只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他的一切具体实现都会由操作系统代劳
			但是，如果使用用户级线程，我们就不得不既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现
			操作系统不但不会帮忙，还会要求我们的具体实现必须与它正确地对接，否则用户级线程就无法被并发地，甚至正确地运行
			毕竟我们编写的所有代码最终都需要通过操作系统才能在计算机上执行
	Go 语言
		Go 语言不但有着独特的并发编程模型，以及用户级线程 goroutine，还拥有强大的用于调度 goroutine、对接系统级线程的调度器
		goroutine 代表着并发编程模型中的用户级线程
调度器：GMP
	调度器是 Go 语言运行时系统的重要组成部分，它主要负责统筹调配 Go 并发编程模型中的三个主要元素
	即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）
	M 指代的就是系统级线程
	P 指的是一种可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介
GMP 关系
	从宏观上说，G 和 M 由于 P 的存在可以呈现出多对多的关系
	当一个正在与某个 M 对接并运行着的 G，需要因某个事件（比如等待 I/O 或锁的解除）而暂停运行的时候
		调度器总会及时地发现，并把这个 G 与那个 M 分离开，以释放计算资源供那些等待运行的 G 使用
	而当一个 G 需要恢复运行的时候，调度器又会尽快地为它寻找空闲的计算资源（包括 M）并安排运行
	另外，当 M 不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个 M 已无用时，调度器又会负责把它及时地销毁掉
小结
	调度器保证 Go 程序总是能高效地利用操作系统和计算机资源
	程序中的所有 goroutine 也都会被充分地调度，其中的代码也都会被并发地运行
	Go 语言实现了一套非常完善的运行时系统，保证了我们的程序在高并发的情况下依旧能够稳定、高效地运行

补充：来自 25.test_03.go
	P 是 processor 的缩写
		每个 processor 都是一个可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接并得到真正运行的中介
		正是由于 P 的存在，G 和 M 才可以呈现出多对多的关系，并能够及时、灵活地进行组合和分离
	G 就是 goroutine 的缩写，可以被理解为 Go 语言自己实现的用户级线程
	M 即为 machine 的缩写，代表着系统级线程，或者说操作系统内核级别的线程
	P
		Go 语言并发编程模型中的 P，正是 goroutine 的数量能够数十万计的关键所在
		P 的数量意味着 Go 程序背后的运行时系统中，会有多少个用于承载可运行的 G 的队列存在
		每一个队列都相当于一条流水线，它会源源不断地把可运行的 G 输送给空闲的 M，并使这两者对接
		一旦对接完成，被对接的 G 就真正地运行在操作系统的内核级线程之上了。每条流水线之间虽然会有联系，但都是独立运作的
	P & -cpu
		最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数
		而go test命令的-cpu标记正是用于设置这个最大个数的
		在默认情况下，最大 P 数量就等于当前计算机 CPU 核心的实际数量
		它们的存在不同大小关系，如此可以在一定程度上模拟拥有不同的 CPU 核心数的计算机
		使用-cpu标记可以模拟被测程序在计算能力不同计算机中的表现

问题：什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同？
	绝大多数情况都会是，不会有任何内容被打印出来
	func main() {
		for i := 0; i < 10; i++ {
			go func() {
				fmt.Println(i)
			}()
		}
	}
问题解析
	go函数真正被执行的时间总会与其所属的go语句被执行的时间不同
	主 goroutine
		与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 goroutine
		这个主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作
		每条go语句一般都会携带一个函数调用，而主 goroutine 的go函数就是那个作为程序入口的main函数
	启用 goroutine
		当程序执行到一条go语句的时候，Go 语言的运行时系统，会先试图从某个存放空闲的 G 的队列中获取一个 G
		它只有在找不到空闲 G 的情况下才会去创建一个新的 G
		已存在的 goroutine 总是会被优先复用
	创建 goroutine
		创建 G 的成本也是非常低的
		创建一个 G 并不会像新建一个进程或者一个系统级线程那样，必须通过操作系统的系统调用来完成
		在 Go 语言的运行时系统内部就可以完全做到了，更何况一个 G 仅相当于为需要并发执行代码片段服务的上下文环境而已
	G 队列 & go函数滞后
		在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个go函数，然后再把这个 G 追加到某个存放可运行的 G 的队列中
		队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行
		虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的
		因此，go函数的执行时间总是会明显滞后于它所属的go语句的执行时间
		只要go语句本身执行完毕，Go 程序完全不会等待go函数的执行，它会立刻去执行后边的语句
			这就是所谓的异步并发地执行
	问题分析
		在执行完 for 语句后，主 goroutine 中的代码也就执行完了，Go 程序会立即结束运行
		严谨地讲，Go 语言并不会去保证这些 goroutine 会以怎样的顺序运行
		由于主 goroutine 会与我们手动启用的其他 goroutine 一起接受调度，又因为调度器很可能会在 goroutine 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会
		所以哪个 goroutine 先执行完、哪个 goroutine 后执行完往往是不可预知的，除非我们使用了某种 Go 语言提供的方式进行了人为干预
	可能的打印
		打印出 10 个 10
		不会有任何内容被打印出来
		打印出乱序的0到9，打印出乱序的0到10

参考
	02.concurrent 包

思考
	用什么手段可以对 goroutine 的启用数量加以限制？
A
	简单且常用的方法是，使用一个通道保存一些令牌
		只有先拿到一个令牌，才能启用一个 goroutine。另外在go函数即将执行结束的时候还需要把令牌及时归还给那个通道
	更高级的手段需要比较完整的设计
		比如，任务分发器 + 任务管道（单层的通道）+ 固定个数的 goroutine
		又比如，动态任务池（多层的通道）+ 动态 goroutine 池（可由前述的那个令牌方案演化而来）等
*/
