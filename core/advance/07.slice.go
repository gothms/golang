package advance

import (
	"fmt"
)

/*
数组和切片

数组类型
	长度是固定的
	数组的长度在声明它的时候就必须给定，并且之后不会再改变
	数组的长度是其类型的一部分
	比如，[1]string和[2]string就是两个不同的数组类型
切片类型
	可变长的
	切片的类型字面量中只有元素的类型，而没有长度
	切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小
vs
	可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组
	数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用
Go vs Java
	Go 语言里不存在像 Java 等编程语言中令人困惑的“传值或传引用”问题
	在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了
值传递
	如果传递的值是引用类型的，那么就是“传引用”
	如果传递的值是值类型的，那么就是“传值”
	从传递成本的角度讲，引用类型的值往往要比值类型的值低很多
内建函数
	通过调用内建函数len，得到数组和切片的长度
	通过调用内建函数cap，我们可以得到它们的容量
	数组的容量永远等于其长度，都是不可变的。切片的容量却不是这样，并且它的变化是有规律可寻的

问题
	怎样正确估算切片的长度和容量？
问题解析
	用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致
	示例：make([]int, 5, 8)
	在这种情况下，切片的容量实际上代表了它的底层数组的长度，这里是8
	比喻：有一个窗口，你可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素
	用make函数或切片值字面量（比如[]int{1, 2, 3}）初始化一个切片时，该窗口最左边的那个小格子总是会对应其底层数组中的第 1 个元素

知识扩展
1. 问题：怎样估算切片容量的增长？
	扩容
		并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中
		在一般的情况下，简单地认为新切片的容量将会是原切片容量的 2 倍
		当原切片的长度大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准
		新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和
		最终，新容量往往会比新长度大一些，当然，相等也是可能的
		另外，如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准？
			最终的新容量在很多时候都要比新容量基准更大一些
		示例：ExpandCap
	源码
		参见runtime包中 slice.go 文件里的growslice及相关函数的具体实现
		runtime.slice.go growslice()
2. 问题：切片的底层数组什么时候会被替换？
	一个切片的底层数组永远不会被替换
		虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片
		它是把新的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动
	append
		在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片
		只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容
		这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉

总结
	一个切片的容量总是固定的，而且一个切片也只会与某一个底层数组绑定在一起
	切片的容量总会是在切片长度和底层数组长度之间的某一个值，并且还与切片窗口最左边对应的元素在底层数组中的位置有关系
	append函数总会返回新的切片，而且如果新切片的容量比原切片的容量更大那么就意味着底层数组也是新的了

思考
	1.如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么？
	2.怎样沿用“扩容”的思想对切片进行“缩容”？
*/

func SliceCap() {
	s := []int{1, 2, 3, 4, 5, 6, 7, 8}
	sl := s[3:6]
	// 一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数
	fmt.Printf("The capacity of sl: %d\n", cap(sl)) // 5
}
func ExpandCap() {
	s := make([]int, 2, 4)
	expand := make([]int, 9) // 实测新容量为 (2+9)+1
	s = append(s, expand...)
	fmt.Printf("The new capacity of s: %d\n", cap(s)) // 12
}
