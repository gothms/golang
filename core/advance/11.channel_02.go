package advance

import (
	"fmt"
	"time"
)

/*
通道的高级玩法

单向通道
	单向通道就是，只能发不能收，或者只能收不能发的通道
	一个通道是双向的，还是单向的是由它的类型字面量体现的
	发送通道 or 接收通道

问题：单向通道有什么应用价值？
	概括地说，单向通道最主要的用途就是约束其他代码的行为
问题解析
	Notifier 接口
		type Notifier interface {
			SendInt(ch chan<- int)
		}
	代码约束
		在某个方法的定义中使用了单向通道类型，那么就相当于在对 Notifier 的所有实现做出约束
		调用函数时，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道
		因为 Go 语言在这种情况下会自动地把双向通道转换为函数所需的单向通道
		还可以在函数声明的结果列表中使用单向通道
	for range channel
		一、for语句会不断地尝试从 Chan 中取出元素值，即使 Chan 被关闭，它也会在取出所有剩余的元素值之后再结束执行
		二、当 Chan 中没有元素值时，它会被阻塞在有for关键字的那一行，直到有新的元素值可取
		三、假设 Chan 的值为nil，那么它会被永远阻塞在有for关键字的那一行

知识扩展
问题 1：select语句与通道怎样联用，应该注意些什么？
	简介
		select语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行
		select语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支
		当且仅当没有候选分支被选中时 default case 才会被执行
		由于select语句是专为通道而设计的，所以每个case表达式中都只能包含操作通道的表达式，比如接收表达式
	select 注意事项
		1. 如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，select语句都不会被阻塞
			如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行
		2. 如果没有加入默认分支，那么一旦所有的case表达式都没有满足求值条件，那么select语句就会被阻塞
			直到至少有一个case表达式满足条件为止
		3. 可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值
			所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭
			一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的
		4. select语句只能对其中的每一个case表达式各求值一次
			所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在for语句中嵌入select语句的方式实现
			但这时要注意，简单地在select语句的分支中使用break语句，只能结束当前的select语句的执行，而并不会对外层的for语句产生作用
			这种错误的用法可能会让这个for语句无休止地运行下去
问题 2：select语句的分支选择规则都有哪些？
	1. 对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式
		比如，如果case表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的
		当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值
	2. select语句包含的候选分支中的case表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的
		结合上一条规则，在select语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式
		仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推
	3. 对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表达式的求值就是不成功的
		在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的
	4. 仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支
		这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行
		如果这时没有默认分支，那么select语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止
		一旦有一个候选分支满足选择条件，select语句（或者说它所在的 goroutine）就会被唤醒，这个候选分支就会被执行
	5. 如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行
		注意，即使select语句是在被唤醒时发现的这种情况，也会这样做
	6. 一条select语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关
	7. select语句的每次执行，包括case表达式求值和分支选择，都是独立的
		不过，至于它的执行是否是并发安全的，就要看其中的case表达式以及分支中，是否包含并发不安全的代码了
	发送和接收操作的阻塞是分支选择规则的一个很重要的依据

思考
	1.如果在select语句中发现某个通道已关闭，那么应该怎样屏蔽掉它所在的分支？
		当第二个boolean参数为false的时候，在相应的case中设置chan为nil零值，再次case求值的时候会遭遇阻塞，会屏蔽该case
	2.在select语句与for语句联用时，怎样直接退出外层的for语句？
*/

// ChannelTest 测试关闭通道
func ChannelTest() {
	intChan := make(chan int, 1)
	// 一秒后关闭通道
	time.AfterFunc(time.Second, func() {
		close(intChan)
	})
	select {
	case _, ok := <-intChan:
		if !ok {
			fmt.Println("The candidate case is closed.") // 一秒后仅输出这行
			break
		}
		fmt.Println("The candidate case is selected.")
	}
}
