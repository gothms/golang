package advance

import "fmt"

/*
结构体及其方法的使用法门

“空”结构体
	一个结构体类型可以包含若干个字段，每个字段通常都需要有确切的名字和类型
	结构体类型也可以不包含任何字段，这样并不是没有意义的
	因为我们还可以为这些类型关联上一些方法
方法 vs 函数
	函数则是独立的程序实体
		我们可以声明有名字的函数，也可以声明没名字的函数，还可以把它们当做普通的值传来传去
		我们能把具有相同签名的函数抽象成独立的函数类型，以作为一组输入、输出（或者说一类逻辑组件）的代表
	方法看做是函数的特殊版本
		方法却不同，它需要有名字，不能被当作值来看待，最重要的是，它必须隶属于某一个类型
		方法所属的类型会通过其声明中的接收者（receiver）声明体现出来
方法
	方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型
	一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名
	并且，如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复
面向对象编程（object-oriented programming）
	把结构体类型中的一个字段看作是它的一个属性或者一项数据
	再把隶属于它的一个方法看作是附加在其中数据之上的一个能力或者一项操作
	将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程（object-oriented programming）的一个主要原则
	Go 语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法
	从这方面看，Go 语言其实是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则

问题：组合中的某个字段声明（只有一个结构体类型名）代表了什么？
	代表了嵌入字段
	Go 语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段
	嵌入字段的类型既是类型也是名称
问题解析
	选择表达式
		在某个代表变量的标识符的右边加“.”，再加上字段名或方法名的表达式被称为选择表达式，它用来表示选择了该变量的某个字段或者方法
		这是 Go 语言规范中的说法
	同名方法
		注意，只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法
		如果这两个结构体类型里存在同名的字段，那么嵌入字段中的那个字段一定会被“屏蔽”
		如果处于同一个层级的多个嵌入字段拥有同名的字段或方法，那么从被嵌入类型的值那里，选择此名称的时候就会引发一个编译错误
		因为编译器无法确定被选择的成员到底是哪一个

知识扩展
问题 1：Go 语言是用嵌入字段实现了继承吗？
	Go 语言中根本没有继承的概念
		它所做的是通过嵌入字段的方式实现了类型之间的组合
		https://golang.org/doc/faq#inheritance
	继承
		面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的
	组合
		类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型
		同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合
			我们要做的只是把类型当做字段嵌入进来，然后坐享其成地使用嵌入字段所拥有的一切
			如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化
		另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型
			这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口
		再者，组合要比继承更加简洁和清晰，Go 语言可以轻而易举地通过嵌入多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本
	接口的组合
		在 Go 语言中，接口类型之间的组合甚至更加常见，我们常常以此来扩展接口定义的行为或者标记接口的特征
问题 2：值方法和指针方法都是什么意思？有什么区别？
	值方法
		接收者类型是非指针的自定义数据类型的方法
		结构体接收器
	指针方法
		指针类型的值表示的是指向某个基本类型值的指针
		指针方法，就是接收者类型是指针类型的方法
		指针接收器
	vs
		1. 值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型
			而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上
		2. 一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法
			严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go 语言会适时地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法
		3. 一个类型的方法集合中有哪些方法与它能实现哪些接口类型是息息相关的
			如果一个基本类型和它的指针类型的方法集合是不同的，那么它们具体实现的接口类型的数量就也会有差异，除非这两个数量都是零
			比如，一个指针类型实现了某某接口类型，但它的基本类型却不一定能够作为该接口的实现类型

思考
	1.我们可以在结构体类型中嵌入某个类型的指针类型吗？如果可以，有哪些注意事项？
		初始值为 nil，因为引用类型的零值为 nil
	2.字面量struct{}代表了什么？又有什么用处？
		空结构体类型变量不占内存空间，内存地址相同，建议用于在通道里传递“信号”
*/

// StructTest 空结构体类型变量不占内存空间，内存地址相同
func StructTest() {
	m := map[int]struct{}{1: {}, 2: {}}
	s1, s2 := m[1], m[2]
	fmt.Println(s1 == s2)            // true
	fmt.Printf("%p, %p\n", &s1, &s2) // 0xe02520, 0xe02520
}
