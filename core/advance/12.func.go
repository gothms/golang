package advance

import "fmt"

/*
使用函数的正确姿势

first-class
	在 Go 语言中，函数是一等的（first-class）公民，函数类型也是一等的数据类型
	函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等
	而更深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）
	“函数是一等的公民”是函数式编程（functional programming）的重要特征。Go 语言在语言层面支持了函数式编程
函数类型
	是一种对一组输入、输出进行模板化的重要工具，它比接口类型更加轻巧、灵活，它的值也借此变成了可被热替换的逻辑组件
	只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，那它们是一样的函数，或者说是实现了同一个函数类型的函数
	严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时，需要给定的标识符而已
零值 nil
	函数类型属于引用类型，它的值可以为nil，而这种类型的零值恰恰就是nil

问题：怎样编写高阶函数？
	只要满足了其中任意一个特点，就可以说这个函数是一个高阶函数
		1.接受其他的函数作为参数传入
		2.把其他的函数作为结果返回
		高阶函数也是函数式编程中的重要概念和特征
	具体问题
		通过编写calculate函数来实现两个整数间的加减乘除运算，但是希望两个整数和具体的操作都由该函数的调用方给出
典型回答
	type operate func(x, y int) int
	func calculate(x int, y int, op operate) (int, error) {...}
		高阶函数：之接受其他的函数作为参数传入
	op := func(x, y int) int {...}
问题解析
	卫述语句是指被用来检查关键的先决条件的合法性，并在检查未通过的情况下立即终止当前代码块的执行的语句
		如 if op == nil { return ...}

知识扩展
问题 1：如何实现闭包？
	自由变量
		在一个函数中存在对外来标识符的引用
		所谓的外来标识符，既不代表当前函数的任何参数或结果，也不是函数内部声明的，它是直接从外边拿过来的
		标识符的专门术语叫自由变量
	闭包简介
		闭包体现的是由“不确定”变为“确定”的一个过程
		闭包函数就是因为引用了自由变量，而呈现出了一种“不确定”的状态，也叫“开放”状态
		也就是说，它的内部逻辑并不是完整的，有一部分逻辑需要这个自由变量参与完成，而后者到底代表了什么在闭包函数被定义的时候却是未知的
		对于像 Go 语言这种静态类型的编程语言而言，我们在定义闭包函数的时候最多也只能知道自由变量的类型
	实现
		高阶函数返回值是一个函数类型时，其定义的匿名的、某个函数类型的函数，就是一个闭包函数
		闭包函数“捕获”的自由变量究竟代表了什么，这一点并不是在定义这个闭包函数的时候确定的，而是在这个闭包函数被调用的时候确定的
		当程序运行到确定的自由变量时，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包
	闭包的意义
		表面上看，我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑
		我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序行为
问题 2：传入函数的那些参数值后来怎么样了？
	示例：FuncTest
		array1 原数组不会改变
		原因是，所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本
		由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值
		在modify函数中修改的只是原数组的副本而已，并不会对原数组造成任何影响
	引用类型
		切片、字典、通道，复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据
		也就是说，这时只是浅表复制，而不是深层复制
		切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝

函数传参注意事项
	可能会关系到程序的稳定和安全
	一个相关的原则是：既不要把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序。

思考
	1.FuncTest 示例中，array1 被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗？
	2.函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗？
		当函数返回指针类型时不会发生拷贝
		当函数返回非指针类型并把结果赋值给其它变量会发生拷贝

补充
	值类型：int float bool string array struct
	引用类型：pointer slice map chan interface
*/

// FuncTest 值传递测试
func FuncTest() {
	// 数组是值类型
	array1 := [3]string{"a", "b", "c"}
	fmt.Printf("The array: %v\n", array1)
	array2 := modifyArray(array1)
	fmt.Printf("The modified array: %v\n", array2) // The modified array: [a x c]
	fmt.Printf("The original array: %v\n", array1) // The original array: [a b c]

	// 参见 10.channel_01.go 思考 2.
	// slice 是引用类型
	s := []int{1, 2, 3}
	modifySlice(s)
	fmt.Println(s) // [1 99 3]

	// 值类型的元素是引用类型
	complexArray1 := [3][]string{
		[]string{"d", "e", "f"},
		[]string{"g", "h", "i"},
		[]string{"j", "k", "l"},
	}
	modifyArrSlice(complexArray1)
	fmt.Println(complexArray1) // [[d e f] [g !!! i] [j k l]]
}
func modifyArray(a [3]string) [3]string {
	a[1] = "x"
	return a
}
func modifySlice(s []int) {
	s[1] = 99
}
func modifyArrSlice(arrSlice [3][]string) {
	arrSlice[1][1] = "!!!"
}
