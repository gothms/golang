package basic

import (
	in "golang/core/basic/internal"
	"os"
)

/*
库源码文件

定义
	不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）
	“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中
程序实体
	在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称
	程序实体的名字被统称为标识符
	标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字

典型回答
	在同一个目录下的源码文件都需要被声明为属于同一个代码包
	如果该目录下有一个命令源码文件，那么为了让同在一个目录下的文件都通过编译，其他源码文件应该也声明属于main包
问题解析：代码包声明的基本规则
	第一条规则
		同目录下的源码文件的代码包声明语句要一致
		也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的
		如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提
	第二条规则
		源码文件声明的代码包的名称可以与其所在的目录的名称不同
		在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致
		对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同

知识精讲
1. 怎样把命令源码文件中的代码拆分到其他代码包？
	更改源码文件所在包时：
		修改包名
		注意小写函数名改为大写开头
2. 代码包的导入路径总会与其所在目录的相对路径一致吗？
	导入路径
		假设相对路径是：golang/core/basic
		而导入路径是：golang/core/实际声明的代码包名
		建议
		源码文件所在的目录相对于 src 目录的相对路径就是它的代码包导入路径
		而实际使用其程序实体时给定的限定符要与它声明所属的代码包名称对应
		通常做法是：为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致
	限定符
		包名. 叫做限定符
		旨在指明右边的程序实体所在的代码包
		只包含了路径中的最后一级，如 lib
	构建或者安装代码包：lib包
		go install puzzlers/article3/q2/lib
		命令会成功完成
			当前工作区的 pkg 子目录下会产生相应的归档文件，具体的相对路径是：
			pkg/darwin_amd64/puzzlers/article3/q2/lib.a
		darwin_amd64就是平台相关目录
		这里与源码文件所在目录的相对路径是对应的
	假如实际包名不是代码包目录名，运行 go run demo5.go，报错：
		./demo5.go:5:2: imported and not used: "puzzlers/article3/q2/lib" as lib5
			导入了puzzlers/article3/q2/lib包，但没有实际使用其中的任何程序实体
			在 Go 语言中是不被允许的，在编译时就会导致失败
		./demo5.go:16:2: undefined: lib
			Go 命令找不到lib.这个限定符对应的代码包
			根本原因就是，我们在源码文件中声明所属的代码包与其所在目录的名称不同
3. 什么样的程序实体才可以被当前包外的代码引用？
	Go 语言中对于程序实体访问权限的规则
		名称的首字母为大写的程序实体才可以被当前包外的代码引用
		否则它就只能被当前包内的其他代码引用
	访问权限划分
		通过名称，Go 语言自然地把程序实体的访问权限划分为了包级私有的和公开的
		对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它
4. 对于程序实体，还有其他的访问权限规则吗？
	模块级私有
		在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用
		这被称为 Go 程序实体的第三种访问权限：模块级私有
	规则
		internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用
		引用前需要先导入这个internal包
		对于其他代码包，导入该internal包都是非法的，无法通过编译
	导入的包报错
		Use of the internal package is not allowed

总结
	代码包声明规则
	代码包导入规则
	程序实体的访问权限规则

思考
	1.如果你需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，那么会产生冲突吗？
		报错：'包名' redeclared as the imported package name
	2.如果会产生冲突，那么怎样解决这种冲突，有几种方式？
		查阅 Go 语言规范
		匿名 _
		别名和 .
		修改包名：不建议

补充
	源码文件名是代码包内部的细节，不对外暴露
*/

// Hello internal 包仅能被该代码包的直接父包及其子包中的代码引用
func Hello(name string) {
	in.Hello(os.Stdout, name)
}
