package basic

import "fmt"

/*
程序实体的那些事儿 （下）

问题：怎样判断一个变量的类型？
典型回答
	使用“类型断言”表达式
	示例：Assert()
问题解析
	{}
		一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）
		struct{}，它就代表了不包含任何字段和方法的、空的结构体类型
		而空接口interface{}则代表了不包含任何方法定义的、空的接口类型
		对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值[]string{}，以及空的字典值map[int]string{}
	类型断言表达式的语法形式是x.(T)
		x代表要被判断类型的那个值
			这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的
			所以，当这里的container变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值
		在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型
			任何类型的值都可以很方便地被转换成空接口的值，具体语法是interface{}(x)
		类型字面量
			用来表示数据类型本身的若干个字符
			圆括号中[]string是一个类型字面量
			比如，string是表示字符串类型的字面量，uint8是表示 8 位无符号整数类型的字面量

知识扩展
1. 你认为类型转换规则中有哪些值得注意的地方？
	类型转换：T(x)
		x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}），还可以是一个表达式
		如果是表达式，那么该表达式的结果只能是一个值，而不能是多个值
		在这个上下文中，x可以被叫做源值，它的类型就是源类型，而那个T代表的类型就是目标类型
		如果从源类型到目标类型的转换是不合法的，那么就会引发一个编译错误
		Go语言规范之转换：https://golang.google.cn/ref/spec#Conversions
	补码
		补码其实就是原码各位求反再加 1
		在 Go 语言以及计算机中都是以补码的形式存储的，主要是为了简化计算机对整数的运算过程
		示例：BinaryTest()
	“陷阱”
		在语言规范或其他官方文档中已经说明在编程语言层面很难检测的东西才是我们应该关注的
		陷阱（或者说坑），大都源于他们需要了解但却不了解的那些知识和技巧
		1. 首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的
			但需要特别注意的是，源整数类型的可表示范围较大，而目标类型的可表示范围较小的情况
			请见示例：BinaryTest()
			一定要记住，当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可
			当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉
		2. 虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点
			否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）
			字符'�'的 Unicode 代码点是U+FFFD
			它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符
			请见示例：IntToString()
			在实际工作中，我们在排查问题时可能会遇到�，你需要知道这可能是由于什么引起的
		3. 关于string类型与各种切片类型之间的互转的
			首先，一个值在从string类型向[]byte类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节
				除了与 ASCII 编码兼容的那部分字符集，以 UTF-8 编码的某个单一字节是无法代表一个字符的
				示例：string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
					UTF-8 编码的三个字节\xe4、\xbd和\xa0合在一起才能代表字符'你'
					而\xe5、\xa5和\xbd合在一起才能代表字符'好'
			其次，一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符
				示例：string([]rune{'\u4F60', '\u597D'}) // 你好
				Unicode标准：https://home.unicode.org/
2. 什么是别名类型？什么是潜在类型？
	声明
		type MyString = string
	类型别名
		别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的
		源类型与别名类型是一对概念，是两个对立的称呼。别名类型主要是为了代码重构而存在的
		Go 官方文档：https://golang.org/design/18130-type-alias
	Go 语言内建的基本类型中就存在两个别名类型
		byte是uint8的别名类型，而rune是int32的别名类型
	类型的再定义 & 潜在类型
		type MyString2 string
		对于这里的类型再定义来说，string可以被称为MyString2的潜在类型
		潜在类型的含义是某个类型在本质上是哪个类型或者是哪个类型的集合
		潜在类型相同的不同类型的值之间是可以进行类型转换的
		因此，MyString2类型的值与string类型的值可以使用类型转换表达式进行互转
		但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是MyString2和string
		另外，即使两个类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值

总结
	Go 语言的开发环境配置、常用源码文件写法，以及程序实体（尤其是变量）及其相关的各种概念
	编程技巧（比如类型推断、变量重声明、可重名变量、类型断言、类型转换、别名类型和潜在类型等）

思考
	1.除了上述提及的那些，你还认为类型转换规则中有哪些值得注意的地方？
	2.你能具体说说别名类型在代码重构过程中可以起到哪些作用吗？
*/

// 类型断言
var container = []string{"zero", "one", "two"}

func Assert() {
	container := map[int]string{0: "zero", 1: "one", 2: "two"}
	// 把container变量的值转换为空接口值的interface{}(container)
	// 以及用于判断前者的类型是否为切片类型 []string 的 .([]string)
	// 如果不接收 ok，当判断为否时就会引发异常，这种异常在 Go 语言中被叫做panic（恐慌），会使 Go 程序崩溃并停止
	value, ok := interface{}(container).([]string)
	fmt.Println(len(value), ok) // 0 false
	fmt.Printf("The element is %q.\n", container[1])
}

// BinaryTest 补码示例
func BinaryTest() {
	// 负数补码其实就是原码各位求反再加 1
	var srcInt = int16(-255)                        // int16类型的值-255的补码是1111111100000001，但是打印值为 -11111111
	fmt.Printf("%d, %[1]b, %d\n", srcInt, srcInt&2) // -255, -11111111, 0
	// 转换为int8类型的值，Go 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到00000001
	dstInt := int8(srcInt) // 最左边一位是0，正整数的补码就等于其原码，所以dstInt的值就是1
	fmt.Println(dstInt)    // 1
}
func IntToString() {
	fmt.Println(string(-1)) // �
}
