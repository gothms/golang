package basic

import "fmt"

/*
程序实体的那些事儿（中）

包级作用域
	程序实体的访问权限有三种：包级私有的、模块级私有的和公开的
	这其实就是 Go 语言在语言层面，依据代码块对程序实体的作用域进行的定义
	包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块
作用域
	一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制
	对“高内聚，低耦合”这种程序设计思想的实践恰恰可以从这里开始
问题
	如果一个变量与其外层代码块中的变量重名会出现什么状况？
	示例：func Scope()
问题解析
	编译通过
	变量使用“就近原则”
		首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量
			注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块
		其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找
		一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了
	限定符
		在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的
		所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的
		特殊情况
			如果我们把代码包导入语句写成import . XXX的形式（注意中间的那个“.”），那么就会让这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体
			在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包

知识扩展
不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？
	区别
		1. 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”
			而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量
		2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个
			而可重名变量中涉及的变量肯定是有多个的
		3. 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型
			而可重名变量之间不存在类似的限制，它们的类型可以是任意的
		4. 如果可重名变量所在的代码块之间存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象
			但是这种现象绝对不会在变量重声明的场景下出现
	可重名变量可以各有各的类型
		应该尽量利用 Go 语言的语法、规范和命令来约束我们的程序，防止隐晦问题
		当可重名变量的值被转换成某个接口类型值，或者它们的类型本身就是接口类型的时候，严格的类型检查就很有必要了

思考
	import . XXX
	如果通过这种方式导入的代码包中的变量与当前代码包中的变量重名了，那么 Go 语言是会把它们当做“可重名变量”看待还是会报错呢？
*/

// 作用域示例，输出如下：
// The block is inner.
// The block is function.
var block = "package"

func Scope() {
	block := "function"
	{
		block := "inner"
		fmt.Printf("The block is %s.\n", block)
	}
	fmt.Printf("The block is %s.\n", block)
}
